1. Conceitos Básicos
Compreender o que é um algoritmo e suas aplicações

Algoritmo é uma sequência finita de instruções bem definidas que, para todo 
conjunto de entradas válidas, produz uma saída e termina. Em termos formais, 
é uma função computável especificada sobre um modelo de computação (RAM, máquina 
de Turing, λ-cálculo etc.).

Propriedades essenciais

Finitude: termina após número finito de passos.
Determinismo e não-determinismo: a maioria é determinística; pode haver randomizados 
(usam aleatoriedade) ou não-determinísticos (modelo teórico).
Definição precisa: cada passo é inequívoco (executável por um agente mecânico).
Efetividade: cada operação é “simples” no modelo de computação adotado.
Generalidade: resolve uma classe de problemas, não apenas uma instância.

Especificação 

Contrato: pré-condições (ex.: array ordenado), pós-condições (ex.: “se existir x, 
retorna índice; senão, −1”).
Domínio das entradas: tipos, limites (n, valores, formatos), casos degenerados (vazio, 
n=1, duplicatas).
Recursos: orçamento de tempo e memória (SLA/throughput/latência).
Critérios de qualidade: correção, robustez, reprodutibilidade, segurança (resistência 
a inputs maliciosos), estabilidade (em ordenação), numerical stability (em cálculo numérico).

Análise de desempenho

Complexidade temporal e espacial: notações O, Θ, Ω.
Cenários: pior caso, médio caso, melhor caso; amortizada.
Localidade de memória & I/O: cache-friendliness, custo de acesso a disco/rede; modelos 
externos (I/O model) quando dados não cabem em RAM.
Escalabilidade prática: benchmarks, profiling, teste com dados reais/sintéticos.

Classes e paradigmas

Exatos vs. aproximação (com fator/garantia).
Greedy, divisão-e-conquista, programação dinâmica, backtracking/branch-and-bound, fluxos/grafos, 
lineares/numéricos.
Online vs. offline, sequenciais vs. paralelos/distribuídos.
Criptográficos, probabilísticos/Monte Carlo, streaming (sub-linear), embarrassingly parallel.

Correção e prova

Invariantes de laço, indução, terminação (função variante decresce), equivalência a 
especificações formais.
Para críticos: verificação por model checking e testes de propriedade (QuickCheck-like).

De algoritmo a programa (engenharia)

Escolha de estruturas de dados (listas, árvores, heaps, hash, grafos).
Representação (tipos, codificações, layout de memória).
Pseudocódigo → implementação (idiomática à linguagem).
Testes: unit (casos borda), integração, fuzzing.
Observabilidade: métricas, logs, tracing.
Hardening: limites, timeouts, uso de memória, paralelismo seguro.

Cubo Mágico (Rubik’s Cube) — busca em espaço de estados

Modelagem

Estado: posição e orientação de 8 cantos e 12 arestas (com restrições de paridade e orientação).
Ações (movimentos): giros de faces (U, D, L, R, F, B e variações).
Objetivo: chegar ao estado resolvido.
Custo: normalmente cada giro custa 1 (Face Turn Metric, FTM).

Algoritmos/práticas

Busca cega: BFS encontra solução ótima, mas o espaço (≈ 4.3×10¹⁹ estados) inviabiliza BFS puro.
IDA*: profundidade iterativa guiada por heurística admissível (ex.: distância em bases de 
padrões/pattern databases) → muito usado em solvers.
Thistlethwaite / Kociemba: decompõem o problema em subgrupos com restrições progressivas; 
encontram soluções curtas muito rápido (quase-ótimas).
Heurísticas: contam “peças fora do subgrupo”, “orientações incorretas”, “aresta/canto mal 
colocado”; geradas por pattern DBs pré-computadas.

Fatos úteis

“Número de Deus” (limite superior do pior caso): 20 movimentos em FTM (prova por Rokicki et 
al., 2010). Em QTM (90°=1, 180°=2), o pior caso conhecido é 26.
Em aplicações reais: IDA* + Kociemba dá soluções de ~18–23 giros em milissegundos, sem garantia 
de ótimo absoluto (mas muito boas).

Torre de Hanói — recursão & divisão-e-conquista

Modelagem

Estado: distribuição de n discos (ordenados por tamanho) em 3 pinos.
Regra: nunca colocar disco maior sobre menor.
Objetivo: mover todos do pino A → C.

Ideia recursiva

Para mover n discos de A→C usando B:
mover n−1 de A→B
mover o maior de A→C
mover n−1 de B→C

Complexidade

Recorrência: T(n) = 2*T(n-1) + 1 ⇒ T(n) = 2^n − 1 movimentos.
Tempo e número de passos exponenciais; espaço da pilha O(n).
Versão iterativa (insight)

Existe estratégia sem recursão usando Gray code ou a regra:
mova o menor disco a cada passo ímpar (ciclicamente entre pinos, sentido depende da 
paridade de n);
nos passos pares, faça o único movimento legal que não envolve o menor.

narração descritiva -> traduzir intenção humana em algo que o computador consiga executar, 
testar ou aprender.

Especificação → Código
Uma boa descrição vira requisitos formais (pré/pós-condições, regras, limites). Isso 
reduz ambiguidade e guia o design de dados, APIs e algoritmos.

Dados estruturados a partir de texto
Narrativas viram estruturas (JSON, tabelas) que a máquina processa. Ex.: pedidos, 
tickets, logs, políticas.

IA/NLP (treino e uso)

Treino: descrições/captions, rótulos e exemplos alimentam modelos (classificação, 
extração, busca semântica).

Execução (prompting): instruções claras em linguagem natural direcionam LLMs (o “prompt” é 
uma narração descritiva bem feita).

Testabilidade (BDD/TDD)
Histórias de usuário e cenários Given/When/Then viram testes automatizados. 
Narração boa = testes reprodutíveis.

Acessibilidade & UX
Textos descritivos (alt text, labels) permitem a leitores de tela e agentes automatizados 
entenderem a interface.

Observabilidade & auditoria
Logs e eventos com descrição rica facilitam depuração, métricas e rastreabilidade.

Boas práticas ao escrever “narração descritiva” para computação

Seja específica: quem, o quê, quando, onde, limites e unidades (5W2H).
Defina termos (glossário) e regras de negócio (inclusive exceções).
Inclua exemplos e contra-exemplos (casos de borda).
Mapeie para estrutura (campos, tipos, formatos).
Critérios de aceitação (como saberei que está correto?).

Fluxograma 

O que é:
Fluxograma é um diagrama que representa, com formas padronizadas e setas, o fluxo de um 
processo/algoritmo: início → etapas → decisões → fim. Ele torna o raciocínio visual, 
facilita comunicação, revisão e automação.

Quando usar

Algoritmos e lógica de programação (ex.: validações, loops, tratamento de erros).
Processos de negócio (ex.: aprovação de pagamento, triagem de chamados).
Documentar e padronizar procedimentos (treinamento/onboarding).
Descobrir gargalos e redundâncias antes de implementar.

Símbolos essenciais (padrão ANSI/ISO)

Início/Fim: elipse.
Ação/Processo: retângulo (ex.: “Calcular total”).
Decisão: losango com saída Sim/Não.
Entrada/Saída: paralelogramo (ex.: “Ler arquivo”).
Conector: círculo (liga partes do diagrama).
Setas: direção do fluxo.

Boas práticas

Escopo claro: defina início/fim e o que está dentro/fora do processo.
Uma entrada, uma saída por bloco (evite “setas cruzando”).
Decisão binária (Sim/Não) com perguntas claras no losango.
Verbo de ação nos retângulos (“Validar CPF”, “Gerar PDF”).
Padronize nomes/termos e unidades (datas, moeda).
Numere etapas críticas para rastreio/logs.
Granularidade adequada: detalhe o suficiente para alguém executar sem dúvidas, 
mas sem virar pseudocódigo prolixo.
Versione (como código): data, autor, mudanças.

Vantagens

Comunicação rápida entre áreas técnicas e negócio.
Ajuda a detectar ambiguidades e exceções.
Base para testes (Given/When/Then), SOPs e automação (RPA/BPM).

Limitações

Escala mal em processos muito grandes/dinâmicos (considere BPMN ou diagramas de atividade UML).
Não descreve bem dados/estruturas (use ERD ou UML de classes para isso).
Do fluxograma ao código (pipeline mental)

Fluxo validado com stakeholders.

Extraia regras e exceções → casos de teste.
Converta cada etapa em funções; decisões em ifs/guards; laços em loops/recursão.
Ligue logs/telemetria aos pontos numerados do diagrama.

Ferramentas úteis

Draw.io / diagrams.net, Lucidchart, Visio, Mermaid (markdown), PlantUML.

2. Diferentes estruturas
Estruturas para repetição e controle de fluxo

Se... Então

É uma estrutura de controle que executa um bloco apenas se uma condição lógica for verdadeira. 
Em algoritmos, decide o caminho do fluxo.

Conceito

Se (condição) então execute A; senão execute B (opcional). A condição é uma expressão booleana 
que resulta em Verdadeiro ou Falso.

Operadores típicos

Relacionais: >, <, >=, <=, ==, !=
Lógicos: E/AND (&&), OU/OR (||), NÃO/NOT (!)

Pequena verdade:

A AND B é verdadeiro só se ambos forem verdadeiros.
A OR B é verdadeiro se pelo menos um for verdadeiro.
NOT A inverte A.

Formas comuns
1) Simples
SE nota >= 7 ENTÃO
  imprimir "Aprovado"
FIMSE

2) Com senão
SE nota >= 7 ENTÃO
  imprimir "Aprovado"
SENÃO
  imprimir "Reprovado"
FIMSE

3) Encadeado (else-if)
SE nota >= 9 ENTÃO
  conceito ← "A"
SENÃO SE nota >= 7 ENTÃO
  conceito ← "B"
SENÃO SE nota >= 5 ENTÃO
  conceito ← "C"
SENÃO
  conceito ← "D"
FIMSE

4) Aninhado (evite excesso)
SE maior_de_idade ENTÃO
  SE tem_documento ENTÃO permitir_entrada()
  SENÃO negar()
SENÃO negar()

Melhor com guarda (early return):

SE NÃO maior_de_idade OU NÃO tem_documento ENTÃO negar(); SAIR
permitir_entrada()

5) Operador ternário (forma compacta)
const status = nota >= 7 ? "Aprovado" : "Reprovado";

Boas práticas

Condições claras e mutuamente exclusivas (ordem importa!).
Parênteses para deixar a lógica explícita.
Short-circuit (&&/||) evita acessos perigosos (ex.: obj && obj.campo).
Comparação vs. atribuição: em JS use === (evita coerção); não confunda = com ==.
Números de ponto flutuante: compare com tolerância (abs(a-b) < 1e-9).
Strings: normalize maiúsculas/minúsculas/acentos antes de comparar.
Teste limites (ex.: 6.99, 7.00, 7.01).

Quando usar (e quando não)

Use Se...Então para ramificar fluxo por regras de negócio.
Prefira tabelas de decisão/mapeamentos quando houver muitas regras estáticas (reduz 
“piramide de if”).
Para muitas alternativas únicas, considere switch/case.

O que é um loop

Um loop executa um bloco de código repetidamente até que uma condição de parada seja 
satisfeita ou até esgotar os elementos de uma coleção/stream. Ele se apoia em quatro partes:

Inicialização (estado inicial, contador, iterador)
Guarda/condição (quando continuar)
Corpo (o que fazer a cada passo)
Progresso (como avançar para terminar: incrementar contador, consumir item, mover ponteiro)
Se qualquer uma delas falhar (principalmente a condição e o progresso), você cria um loop infinito.

Tipos comuns

Contado: número de iterações conhecido ou previsível.
JS: for (let i = 0; i < n; i++) { ... }

Controlado por condição: repete enquanto algo for verdadeiro.
JS: while (cond) { ... }

Pós-teste: avalia a condição depois da primeira execução (garante ≥1 iteração).
JS/C/Java: do { ... } while (cond);

For-each/iterativo: percorre elementos de coleções/streams.
JS: for (const x of colecao) { ... }

Conceitos que elevam a qualidade
1) Invariante de loop

Uma propriedade que se mantém verdadeira antes e após cada iteração.
Ex.: ao varrer um array para achar o máximo, o invariante pode ser “max é o maior valor visto 
até agora”.
Use assert para checagens durante desenvolvimento.

2) Medida de terminação

Tenha um valor que diminui (ou um espaço que se esgota) a cada passo: contador que vai a zero, 
ponteiro que avança, fila que esvazia. Isso prova que o loop termina.

3) Complexidade

Tempo ≈ iterações × custo do corpo.
Um loop simples sobre n itens → O(n).
Dois loops aninhados n×m → O(n·m).
Otimize reduzindo iterações, corpo e acessos à memória (cache/localidade).

4) Localidade de memória

Percorra estruturas contíguas (ex.: arrays) com passo 1 (stride 1). Isso melhora cache, permite 
vetorização e aceleração. A ordem de acesso importa muito para desempenho.

5) Transformações úteis

Fusão: combinar dois loops sobre a mesma coleção para reduzir leituras.
Fissão: separar loops quando isso simplifica cache ou paraleliza melhor.
Elevação de invariantes: mover cálculos invariantes do corpo para fora.
Desenrolar (unrolling): processar vários elementos por iteração (micro-otimização).

6) Padrões de alto nível

map / filter / reduce (ou compreensões e geradores no Python): expressam loops de forma 
declarativa e podem habilitar otimizações.
Early exit: saia cedo com break quando já tem o resultado (melhora latência média).
Sentinela: itere até ler um valor especial (EOF, None, string vazia).

Armadilhas clássicas

Off-by-one: errar limites (< vs <=, range(n) vs range(n+1)).
Mutar a coleção enquanto itera (pode pular/duplicar itens). Em Python, itere sobre cópia 
ou colete índices/alvos primeiro.
Comparação de floats na condição (use tolerância).
Assíncrono em JS: for...of com await respeita ordem; map(async) + Promise.all paraleliza (mas muda 
semântica).

3. Eficiência de algoritmos
Vale a pena entender porque algoritmos resolvem um mesmo problema com mais
ou menos eficiência

Comparação entre diferentes métodos de busca

1) O que significa eficiência

Tempo: quantas etapas o algoritmo executa conforme o tamanho dos dados n cresce 
(complexidade: O(n), O(n log n), O(n²)…).
Memória: espaço extra usado (O(1), O(log n), O(n)…).
Outros custos: acessos a disco/rede, cache de CPU, energia. Em produção, isso vira latência 
(p50/p95/p99), throughput e custo de infra.

Big-O compara crescimento; constantes e implementação (cache, branch, alocação) ainda 
importam, mas o fator de crescimento domina conforme n aumenta.

2) O impacto prático no sistema

Experiência do usuário: páginas/listas que carregam em ms vs. segundos.
Escalabilidade: com O(n log n) você dobra dados e cresce pouco; com O(n²) tudo degrada rápido.
Custo: menos CPU/RAM/IO = menos máquinas, menos conta na nuvem.
Energia/bateria (mobile) e janela de processamento (jobs noturnos).

Exemplo rápido (ordens de grandeza)

Procurar em 10 milhões de itens:
Linear O(n): ~10.000.000 comparações.
Binária O(log n) (dados ordenados):
2²³ = 8.388.608; 2²⁴ = 16.777.216 → precisa 24 passos no pior caso.
Hash (bem dimensionado): ~1–2 sondagens em média.

Ordenar 1 milhão:

log₂(1.000.000) ≈ 20 (pois 2²⁰=1.048.576) → O(n log n) ≈ 20.000.000 comparações típicas.
O(n²) seria ~1.000.000.000.000 passos (inviável).

3) Busca e Ordenação: por que estão no centro
Busca

Linear (scan): O(n). Boa para coleções minúsculas ou “uma vez na vida”.
Binária: O(log n), exige dados ordenados.
Hash: O(1) médio / O(n) pior; ótima para igualdade, ruim para intervalos.
Árvores balanceadas (AVL, Red-Black, B-Tree/B+Tree): O(log n) para buscar, inserir, remover 
e range queries. É o que bancos usam em índices.

Ordenação

Quicksort: O(n log n) médio, in-place; pior caso O(n²) (randomizado evita na prática).
Mergesort: O(n log n) estável; ótimo para streams/arquivos (external sort).
Heapsort: O(n log n) in-place, não estável.
Timsort (Python/Java): O(n log n), detecta runs; excelente em dados quase ordenados.
Interação entre eles
Ordenar para buscar: paga O(n log n) uma vez e depois busca em O(log n) (ou O(1) com hash).
Índices em DB = estruturas ordenadas (B+Tree) que fazem WHERE x BETWEEN a AND b e ORDER BY 
x ficarem rápidos.
Top-K: não precisa ordenar tudo. Use heap de tamanho K: O(n log K).
Ex.: K=100 e n=1.000.000 → log₂(100) ≈ 7 → ~7.000.000 operações (bem menor que ordenar tudo).

4) Desempenho além da Big-O

Localidade de memória: percorrer arrays com passo 1 usa melhor o cache (às vezes 2–10× mais 
rápido com mesma Big-O).
I/O > CPU: se os dados não cabem em RAM, pense em external sort, paginado, chunking e streaming.
Padrões de uso: leitura-pesada → índices e caches; escrita-pesada → menos índices (cada insert 
custa log n).
Distribuído: partições/chaves consistentes, merge sort distribuído, map-reduce.

5) Guia de escolha (rápido)

Busca pontual e rara em lista pequena → linear.
Muitas buscas no mesmo conjunto:
igualdade → hash (map/set);
intervalos/ordenação → árvore/índice (B+Tree) ou ordenar + busca binária.
Top-K / median / percentis → quickselect / heap K, não ordene tudo.
Dados quase ordenados → Timsort.
Dados maiores que a RAM → mergesort externo, índices em disco.

6) Check de engenharia

Meça (profiling), olhe p95/p99;
Evite O(n²) em JOIN/dedupe (use hash/índices);
Prefira algoritmos que reduzam leituras dispersas;
Se “procuro muito” → indexe; se “ordeno muito” → questione se precisa ordenar tudo.

Busca sequencial (linear)

Como funciona: varre a coleção do início ao fim até achar o alvo.
Pré-requisitos: nenhum (serve para dados não ordenados, stream, listas ligadas).
Complexidade:
Melhor: O(1) (primeiro elemento)
Médio/pior: O(n)
Memória: O(1)
Observações: muito cache-friendly (acesso contíguo); ótima para coleções pequenas ou uma 
busca esporádica; funciona mesmo se você não puder ordenar.

Busca binária

Como funciona: compara com o meio e descarta metade a cada passo.
Pré-requisitos: dados ordenados e acesso aleatório (array/vetor).
Complexidade:
Melhor: O(1)
Médio/pior: O(log n) (≈ 20 passos para 1 milhão de itens)
Memória: O(1)
Observações: salta na memória (menos localidade, mais branching), mas a queda de 
O(n) → O(log n) domina para coleções médias/grandes; em listas ligadas não funciona bem 
(sem acesso aleatório).

Qual é “melhor”?

Dados não ordenados ou poucos itens / poucas buscas → sequencial.
Muitas buscas no mesmo conjunto → binária, se puder manter ordenado.
Precisa de intervalos (≥, ≤) e inserções/remoções frequentes → use estruturas ordenadas 
(árvore balanceada/B-tree) para O(log n) geral.
Só igualdade e altíssima taxa de consultas → um hash bem dimensionado dá O(1) médio (melhor 
que binária), mas não resolve intervalos/ordenação.
“Nível de qualidade” (como avaliar o algoritmo)
Corretude: encontra se existe; trata duplicatas (primeiro/último?); lida com vazios/limites.
Eficiência temporal: O(n) vs O(log n) conforme o tamanho n e o número de consultas.
Eficiência espacial: ambas O(1) extras (fora da coleção).
Pré-condições explícitas: binária exige ordenação (e tipo de acesso).
Comportamento prático: localidade de memória (sequencial favorecida), custo de manter ordenado 
(binária favorecida quando há muitas consultas).

4. Resumos e dicas
Diferentes formas de representação

VisualG (Portugol “texto”)

O que é: um ambiente para escrever pseudocódigo em português (Portugol) e executar passo a passo.
Para quem: iniciantes que querem pensar como programadores com texto, mas sem a carga de uma 
linguagem “real”.

Pontos fortes

Sintaxe simples (português): se, então, enquanto, para, repita.
Execução passo a passo, variáveis/watch, entrada/saída no console.
Ótimo para treinar condicionais, laços, vetores/matrizes e funções.

Limites

Não é uma linguagem de produção; serve para fundamentos.
Poucos recursos gráficos/multimídia.

Scratch (blocos visuais)

O que é: linguagem em blocos (arrastar e soltar), criada pelo MIT, com sprites, palco, 
sons e eventos.
Para quem: iniciantes (inclusive crianças) e educadores; excelente para pensamento 
computacional, criatividade e prototipagem visual.

Pontos fortes

Zero sintaxe: blocos encaixam apenas onde faz sentido (evita erros).
Eventos e concorrência simples (“quando bandeira verde for clicada”, broadcast).
Multimídia: animações, jogos, interações com câmera/microfone.

Limites

Menos adequado para matemática pesada/estruturas complexas.
Transição para texto exige depois migrar para Python/JS, etc.
Esqueleto (soma de 1 até N)
Evento: quando bandeira verde clicada
pergunte “N?” e espere
defina soma = 0 ; defina i = 1
repita até i > resposta:
mude soma por i
mude i por 1
diga junte "Soma: " soma

Um algoritmo, em sua essência, é um conjunto preciso de instruções organizadas logicamente para realizar uma tarefa específica. Imagine uma receita de bolo: os ingredientes são as entradas, o processo de mistura e cozimento é o processamento e o bolo final é a saída. Essa analogia se aplica a qualquer algoritmo, desde os mais simples até os mais complexos.
Existem diversas formas de representar um algoritmo, cada uma com suas vantagens e desvantagens. A narração descritiva, como o próprio nome sugere, descreve os passos em linguagem natural, mas pode ser ambígua e sujeita a interpretações. Os fluxogramas utilizam símbolos gráficos para ilustrar o fluxo de execução, tornando a visualização mais intuitiva. Já o pseudocódigo emprega uma linguagem intermediária entre a linguagem natural e a linguagem de programação, facilitando a transcrição para uma linguagem específica posteriormente.
As estruturas de controle são elementos essenciais em algoritmos, pois permitem controlar o fluxo de execução das instruções. A estrutura de seleção "se-então-senão" possibilita a escolha de um bloco de código a ser executado com base em uma condição. A estrutura de repetição "enquanto" executa um bloco de código repetidamente enquanto uma condição for verdadeira. Já a estrutura "repita-até" executa um bloco de código pelo menos uma vez e o repete até que uma condição seja satisfeita.
A busca por um elemento em uma lista é um problema clássico na computação, e existem diferentes algoritmos para resolvê-lo. A busca sequencial percorre a lista elemento por elemento até encontrar o valor desejado ou chegar ao final da lista. Esse método é simples, mas pouco eficiente para listas grandes, pois o tempo de busca cresce linearmente com o tamanho da lista.
A busca binária, por outro lado, exige que a lista esteja ordenada e realiza a busca dividindo a lista pela metade a cada passo. Se o elemento buscado for menor que o elemento do meio da lista, a busca continua na metade inferior; caso contrário, na metade superior. Esse processo se repete até que o elemento seja encontrado ou a lista seja reduzida a um único elemento. A busca binária é muito mais eficiente que a busca sequencial para listas grandes, pois o tempo de busca cresce logaritmicamente com o tamanho da lista.
A eficiência de um algoritmo é crucial, especialmente quando lidamos com grandes volumes de dados. Um algoritmo eficiente utiliza menos recursos computacionais, como tempo de processamento e memória, para realizar a mesma tarefa. A escolha do algoritmo mais eficiente depende do problema específico e das características dos dados.
Para quem está iniciando no mundo da programação, existem ferramentas que facilitam o aprendizado de algoritmos. O VisualG é um software gratuito que permite criar, editar, interpretar e executar algoritmos em Portugol, uma linguagem em português estruturado que facilita a compreensão dos conceitos básicos de programação.
Outra ferramenta interessante é o Scratch, um ambiente de programação visual desenvolvido pelo MIT que permite criar animações, jogos e histórias interativas utilizando blocos de código. O Scratch é uma excelente forma de aprender lógica de programação de forma lúdica e intuitiva, sem a necessidade de decorar sintaxe complexa.
Em suma, o estudo de algoritmos é fundamental para qualquer pessoa que deseja ingressar na área da computação. Compreender os conceitos básicos, as estruturas de controle, os diferentes tipos de algoritmos e as ferramentas disponíveis é essencial para desenvolver soluções eficientes e inovadoras para os mais diversos problemas.