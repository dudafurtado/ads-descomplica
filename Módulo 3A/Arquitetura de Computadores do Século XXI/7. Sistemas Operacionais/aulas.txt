1. Conceitos I 

Modelo de Von Neumann

Programa armazenado: instruções e dados ficam na mesma memória. A CPU busca 
uma instrução, decodifica e executa, repetidamente (fetch–decode–execute).
Componentes lógicos: CPU, memória principal, dispositivos de E/S (entrada/saída) 
e barramentos que interligam tudo.
Implicação para SO: como instruções são dados na RAM, o SO impõe espaços de 
endereçamento e proteção (modo usuário/kernel, MMU, páginas) para evitar execução 
indevida.
Bottleneck clássico: “von Neumann bottleneck” — CPU muito rápida esperando 
memória/barramento.
Contraste: arquitetura Harvard separa fisicamente instruções e dados (típico em 
microcontroladores/CPUs de sinal).

CPU, ULA, UC (e registradores)

CPU: executa instruções e coordena o sistema.
ULA (ALU): faz operações aritméticas e lógicas (soma, AND, shifts). Normalmente 
há FPU (ponto flutuante) e extensões SIMD (vetoriais).
UC (Unidade de Controle): orquestra o ciclo buscar–decodificar–executar, gerando 
sinais de controle; pode ser hardwired ou microprogramada.
Registradores: armazenamento ultrarrápido dentro da CPU. Destacam‐se:
PC (Program Counter): endereço da próxima instrução.
IR (Instruction Register): instrução corrente.
SP (Stack Pointer), FLAGS e GPRs (registradores de uso geral).
Pipelines e interrupções: a UC gerencia pipeline (múltiplas instruções em voo). 
Interrupções desviam o fluxo para o kernel (tratadores), base do I/O e do agendamento.
Visão do SO: o kernel realiza troca de contexto salvando/restaurando registradores; 
usa instruções privilegiadas e tabelas da MMU (mapeamento virtual→físico).

Memória, instruções, drivers

Memória

Hierarquia: registradores → L1/L2/L3 (cache) → RAM → armazenamento (SSD/HDD).
Localidade: SO e compilador tentam maximizar localidade temporal/espacial (páginas, 
layout de dados).
Virtualização: cada processo enxerga memória virtual; a MMU traduz para físico 
via page tables; faltas de página viram interrupções tratadas pelo kernel.

Instruções (formato e ciclo)

Uma instrução = opcode + operandos (+ modo de endereçamento).
Ciclo: Fetch (PC→busca), Decode (UC decifra), Execute (ULA/ memória/ E/S), 
Writeback (resultado em registro/memória), PC++ (salta/branch se necessário).

Drivers

Drivers são módulos do kernel que “falam” o protocolo do dispositivo (MMIO/PIO, 
DMA, interrupções) e expõem uma abstração uniforme (arquivos de dispositivo, APIs).
Fluxo típico: dispositivo gera interrupção → driver lê status/registros 
mapeados → agenda trabalho (softirq/thread) → entrega dados ao subsistema 
(rede, bloco, vídeo).
DMA: evita cópia pela CPU; o driver programa o controlador para transferir direto 
memória↔dispositivo pelo barramento.

Barramentos

Função: transportar endereços, dados e sinais de controle entre CPU, memória e 
dispositivos.

Três lógicos básicos:

Endereços: “para onde ler/escrever”.
Dados: “o que” transferir.
Controle: clock, leitura/escrita, confirmação, interrupções.

Exemplos práticos:

Barramento de memória (canal DDR): altíssima largura de banda, baixa latência.
PCI Express (PCIe): interliga controladores (GPU, NVMe, rede) em lanes seriais de 
alta velocidade, com enumeration feita pelo SO.
SATA/USB: armazenamento e periféricos externos.
Interconexões de CPU: QPI/UPI (Intel), Infinity Fabric (AMD).
Taxa efetiva (simplificada): largura(bytes) × transferências_por_ciclo × frequência. 
O SO sente isso em throughput de I/O e tempo de resposta.

2. Conceitos II
Software, sistemas operacionais

Tipos de software

Sistema: sistemas operacionais, drivers, firmware, bibliotecas do sistema, 
shells, utilitários (backup, antivírus).
Aplicativo: apps de produtividade, ERPs, navegadores, editores, jogos.
Desenvolvimento: compiladores, interpretadores, depuradores, IDEs, linters, build/CI.
Middleware/Infra: bancos de dados, mensageria, servidores de aplicação, 
proxies/reversos, runtimes (JVM, .NET), hipervisores (KVM/Hyper-V/ESXi) e 
containers (runtimes OCI).
Embarcado/Tempo real: software de controladores, automotivo, IoT, robótica.

Sistema operacional (o que faz)

Abstrações: processos/threads, arquivos, sockets, pipes, dispositivos.
Gerência de CPU: escalonamento, preempção, prioridades, afinidade/NUMA.
Memória: espaço de endereços virtual, paginação, COW, mapeamento de arquivos, 
proteção/ASLR.
I/O e FS: cache de página, filas de I/O, sistemas de arquivos, quotas, ACLs.
Dispositivos: drivers, interrupções, DMA, hotplug/plug-and-play.
Rede: pilha TCP/IP, filtros, QoS.
Segurança: modo usuário/kernel, chamadas de sistema, capabilities, auditoria.
Boot & power: inicialização (firmware→kernel), ACPI, hibernação/suspensão.

Evolução do sistema operacional da Apple (linha do tempo resumida)

1984–2001 – Classic Mac OS (System 1 → Mac OS 9): GUI pioneira, sem 
preempção/memória protegida.
Anos 90 – A/UX, Copland (tentativas): transição fracassada para um kernel moderno.
1997–2001 – NeXT + Rhapsody → Mac OS X 10.0: base Darwin (kernel XNU = Mach + BSD), 
APIs Cocoa/Carbon, interface Aqua.
2001–2012 – OS X 10.1…10.8: maturação (Quartz, Spotlight, Time Machine), transição 
PowerPC→Intel (2006), Snow Leopard foco em performance.
2013–2015 – OS X 10.9 Mavericks → 10.11: ciclo anual, refinamentos.
2016 – Renomeado para “macOS” (10.12 Sierra).
2017 – 10.13 High Sierra: APFS (novo sistema de arquivos).
2019 – 10.15 Catalina: fim do 32-bit, Catalyst.
2020 – macOS 11 Big Sur: redesign, transição Intel→Apple Silicon (ARM64).
2021–2024 – 12 Monterey, 13 Ventura, 14 Sonoma, 15 Sequoia: continuidade em 
segurança, integração com iOS/iPadOS e otimizações para M-series.
Família móvel: iPhone OS/iOS (2007–), iPadOS (2019–), watchOS/tvOS e visionOS — 
todos sobre base Darwin/XNU.

Tipos de sistemas operacionais

Batch e timesharing/interactive (mainframes e multiusuário).
Desktop/Servidor (Windows, macOS, Linux) vs Mobile/Embarcado (Android, iOS, RTOS).
Tempo real: hard/soft RT (VxWorks, QNX, RT-Linux).
Distribuídos e clusterizados (gestão de nós/recursos, ex.: Kubernetes sobre Linux).
Núcleo: monolítico (Linux), microkernel (QNX, seL4), híbrido (Windows NT, XNU).
Virtualização: hipervisores tipo 1 (bare-metal) e tipo 2; containers compartilham kernel.

Memória, instruções, drivers (visão do SO)

Memória: cada processo vê um espaço virtual isolado; a MMU traduz para físico via 
page tables; faltas de página viram traps para o kernel; swap/compressão atendem 
pressão de memória. COW reduz cópias; ASLR endurece segurança.
Instruções: CPU separa modo usuário (sem privilégios) de modo kernel (privilégios). 
A passagem usa syscalls (trap); apenas o kernel executa operações privilegiadas 
(I/O mapeado, alteração da MMU).
Drivers: módulos que falam com hardware por MMIO/PIO, interrupções e DMA. Podem 
rodar no kernel (rápido, mais risco) ou em user space (FUSE/UMD em alguns casos). 
O SO faz enumeration do dispositivo, carrega driver, e expõe uma API/arquivo de 
dispositivo.

Barramentos (o “nervo” do I/O)

Função: transportar endereços, dados, controle entre CPU, RAM e dispositivos.
Memória: canais DDR (largura × frequência × transferências).
I/O interno: PCIe (lanes seriais; GPU, NVMe, rede; hotplug em PCIe/Thunderbolt).
Armazenamento: NVMe (sobre PCIe), SATA.
Periféricos externos: USB (hosts, hubs, classes), Thunderbolt (tunela PCIe/DP).
Interconexão de CPUs: UPI/QPI (Intel), Infinity Fabric (AMD).
Papel do SO: detectar (ACPI/PCIe enumeration), ligar driver, configurar MSI/MSI-X 
para interrupções, programar DMA e escalonar filas de I/O para throughput/latência.

3. Funcionalidades
Exemplos

1) Ciclos de execução da CPU (do ponto de vista do SO e do hardware)

Ciclo básico (von Neumann): fetch → decode → execute → writeback → PC←próxima
PC (Program Counter): endereço da próxima instrução.
IR (Instruction Register): instrução corrente.
UC (unidade de controle): decodifica e gera sinais.
ULA/FPU/SIMD: realiza a operação.
Acesso à memória/registradores: lê operandos, grava resultados.

Pipeline (ex.: 5 estágios IF/ID/EX/MEM/WB): várias instruções “em voo” ao mesmo 
tempo (uma em IF, outra em ID, etc.).
O hardware lida com hazards (dados/controle/estruturais) via forwarding, stalls 
e predição de desvio.

Interrupções e SO: entre instruções (ou em pontos bem definidos) a CPU desvia para 
o vetor de interrupção, o kernel salva registradores (troca de contexto), executa 
o tratador (timer, rede, disco), e retorna.

2) Rotina de bootstrap (do reset ao kernel rodando)

Objetivo: sair do estado mínimo de hardware e chegar ao kernel do SO carregado 
na RAM e em execução.
Linha do tempo típica (x86, duas variantes)
BIOS legado (MBR)
Reset → PC carrega reset vector (firmware/ROM).
POST (teste e init de hardware básico), encontra disco de boot.
Lê MBR (512 B) para RAM e pula para ele (stage-1 do bootloader).
Stage-1 carrega stage-2 (p. ex., GRUB) de uma região maior do disco.
Bootloader seleciona kernel + initrd, configura modo protegido/long mode, passa a 
mão na tabela de memória.
Carrega kernel na RAM, passa parâmetros e transfere o controle (jump para a entry 
do kernel).
Kernel inicializa MMU, page tables, drivers básicos, monta root FS, sobe PID 1 
(systemd/launchd).
UEFI (atual)
Reset → firmware UEFI inicializa dispositivos e expõe Boot Services.
Carrega um EFI executable (bootloader ou o próprio kernel “EFI stub”) do ESP 
(EFI System Partition).
Passa memmap, ACPI e parâmetros; ExitBootServices() entrega o controle total ao kernel.
Kernel continua como acima.
ARM/embarçados (visão rápida): Boot ROM → SPL (init DRAM) → bootloader 
(U-Boot) → kernel + dtb + initramfs.

4. Resumos e dicas
Vale a pena entender porque algoritmo resolvem um mesmo problema com mais
ou menos eficiencia

1) Por que algoritmos resolvem o mesmo problema com eficiências diferentes

Modelo de custo: tempo ≈ número de passos + latência de memória/I/O; 
espaço ≈ memória extra.

Complexidade assintótica manda no crescimento:

Busca: linear O(n) vs. binária O(log n) (se ordenado) vs. hash O(1) médio.
Ordenação: O(n log n) (merge/quick/timsort) vs. O(n²) (insertion/selection).
Constantes & hardware importam: acesso contíguo (cache) pode fazer um O(n) real 
ser mais rápido que um O(n log n) mal localizado para tamanhos pequenos/médios.

Padrão de uso decide a escolha:

Muitas consultas? invista em índice (árvore/ordenar uma vez).
Só igualdade? hash; precisa de intervalo/ordem? árvore/ordenado.
Quer Top-K? não ordene tudo → heap K ou quickselect.
Regra de bolso: otimizar estruturas de dados + acesso à memória costuma render 
mais que micro-otimizar instruções.
Checklist rápido: defina n, operações dominantes (buscar, inserir, ordenar), 
limites de tempo/memória, padrão de acesso (sequencial x aleatório), e escolha a 
estrutura com melhor custo total.

2) Esquema geral de um computador

CPU executa instruções (ciclo fetch–decode–execute), trata interrupções e segue 
políticas do SO (troca de contexto).
MMU + SO dão memória virtual por processo (isolamento).
Drivers traduzem comandos do SO para protocolos de hardware; DMA transfere dados 
sem ocupar CPU.
Barramentos (PCIe, DDR, USB) movem endereços/dados/sinais.

3) Simulador DrMIPS — como tirar proveito estudando arquitetura

O que ele mostra: um pipeline MIPS clássico (IF, ID, EX, MEM, WB), registradores, 
memória e hazards (dados/controle), com forwarding e stalls.

4) “O ser humano é mais complexo que as máquinas”

Máquinas: força bruta em velocidade, precisão repetitiva, paralelismo massivo; 
ótimas quando o problema é bem definido (algoritmos, dados completos, função de custo).
Humanos: contexto, ambiguidade, criatividade, heurísticas, percepção multimodal e 
valores sociais — essenciais para definir o problema, trade-offs e interpretar resultados.
Síntese prática: deixe a máquina computar e o humano orientar/validar. Em engenharia, 
isso vira: prototipar, medir, decidir com dados, mas mediado por objetivos de 
produto/usuário.

O funcionamento de um computador depende da interação complexa entre seus componentes 
de hardware e software. O modelo de Von Neumann, proposto na década de 1940, ainda 
serve como base para a arquitetura da maioria dos computadores modernos. Esse modelo 
descreve um sistema composto por uma unidade central de processamento (CPU), memória 
principal, dispositivos de entrada e saída, e um barramento que interliga esses 
componentes. A CPU, frequentemente comparada ao cérebro humano, é responsável por 
buscar, decodificar e executar instruções armazenadas na memória. Ela é composta 
pela unidade lógica e aritmética (ULA), que realiza operações matemáticas e lógicas, 
e pela unidade de controle (UC), que gerencia a execução das instruções.

A memória, por sua vez, armazena dados e instruções que a CPU precisa para operar. 
Existem diferentes tipos de memória, como a memória RAM, que é volátil e armazena 
dados temporariamente enquanto o computador está ligado, e a memória ROM, que é não 
volátil e armazena dados permanentemente, como o firmware do sistema. Os dispositivos 
de entrada, como teclado e mouse, permitem ao usuário inserir dados no sistema, 
enquanto os dispositivos de saída, como monitor e impressora, exibem ou imprimem os 
resultados do processamento. O barramento atua como um canal de comunicação entre 
esses componentes, transmitindo dados e instruções entre eles.

Para que o computador funcione corretamente, é necessário um sistema operacional (SO), 
um conjunto de programas que gerencia os recursos de hardware e fornece uma interface 
para o usuário interagir com o sistema. O SO é responsável por gerenciar a execução 
de programas, alocar memória, controlar o acesso aos dispositivos de entrada e saída, 
entre outras funções essenciais. Quando o computador é ligado, a rotina bootstrap, 
armazenada na memória ROM, é executada. Essa rotina inicializa o hardware e carrega 
o sistema operacional da memória secundária, como o disco rígido, para a memória RAM, 
tornando-o operacional.

O sistema operacional permite que vários programas sejam executados simultaneamente, 
gerenciando o tempo de CPU e os recursos de memória para cada processo. Um processo é 
um programa em execução, e o SO utiliza algoritmos de escalonamento para determinar 
qual processo terá acesso à CPU em determinado momento. Os processos podem estar em 
diferentes estados, como novo, pronto, em execução, em espera ou terminado, dependendo 
de sua interação com a CPU e outros recursos do sistema.

Além do sistema operacional, existem diversos tipos de software, como programas 
aplicativos, utilitários e drivers. Os programas aplicativos são projetados para 
realizar tarefas específicas para o usuário, como editores de texto, navegadores da 
web e jogos. Os utilitários são programas que auxiliam na manutenção e configuração 
do sistema, como programas antivírus e gerenciadores de arquivos. Os drivers são 
softwares que permitem que o sistema operacional se comunique com dispositivos de 
hardware específicos, como placas de vídeo, impressoras e scanners.

A evolução dos sistemas operacionais tem sido marcada por avanços significativos 
na interface com o usuário, no gerenciamento de recursos e na conectividade. Desde 
os primórdios da computação, com interfaces de linha de comando, os sistemas 
operacionais evoluíram para interfaces gráficas intuitivas, como as encontradas 
nos sistemas Windows, macOS e Linux. Essas interfaces facilitam a interação do 
usuário com o sistema, permitindo a realização de tarefas complexas de forma mais 
intuitiva e eficiente.

Os sistemas operacionais modernos também oferecem recursos avançados de gerenciamento 
de memória, como paginação e segmentação, que permitem que o sistema utilize a memória 
de forma mais eficiente e execute programas maiores do que a capacidade da memória 
RAM. A conectividade em rede também se tornou uma característica essencial dos 
sistemas operacionais, permitindo que computadores se comuniquem entre si e 
compartilhem recursos, como impressoras e arquivos.

A escolha do sistema operacional depende das necessidades específicas do usuário 
e do tipo de hardware utilizado. Sistemas operacionais desktop, como Windows, 
macOS e Linux, são projetados para uso em computadores pessoais e oferecem uma 
ampla gama de aplicativos e recursos para usuários domésticos e corporativos. 
Sistemas operacionais para servidores, como Linux, Windows Server e macOS Server, 
são otimizados para gerenciar grandes quantidades de dados e tráfego de rede, sendo 
utilizados em servidores web, de banco de dados e de aplicativos.

Sistemas operacionais embarcados, como FreeRTOS e Contiki, são projetados para 
dispositivos com recursos limitados de hardware, como dispositivos móveis, 
eletrodomésticos e sistemas de controle industrial. Esses sistemas operacionais 
são otimizados para baixo consumo de energia e tempo real, garantindo o funcionamento 
confiável de dispositivos críticos.

Em resumo, o sistema operacional é um componente essencial de qualquer sistema 
computacional, fornecendo uma plataforma estável e eficiente para a execução de 
aplicações e o gerenciamento de recursos de hardware. A compreensão dos conceitos 
básicos de sistemas operacionais, como processos, gerenciamento de memória, 
entrada e saída, e a interação entre hardware e software, é fundamental para o 
desenvolvimento e a utilização eficaz de sistemas computacionais.