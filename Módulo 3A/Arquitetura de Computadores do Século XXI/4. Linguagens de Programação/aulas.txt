1. Visão panorâmica
Conhecer quais são algumas das principais linguagens

Para que serve uma linguagem de programação?
O ser humano tem uma ideia e com raciocínio lógico utiliza da lógica de
programação para criar um algoritmo que atráves da linguagem de programação
define um programa de computador escritor em código fonte e traduzido para
linguagem de máquina executada pela máquina.

Por que tantas linguagens?
Diferenças nos domínios de aplicação das linguagens de programação:
Inteligencia Artificial
Educação (Ensino de Programação)
Ciência e Engenharia
Sistemas de Informação
Sistemas e Redes
World Wide Web

Variedade de linguagens

Basic (inclui Visual Basic/VBA) — Ainda muito presente em automação de planilhas 
e sistemas internos via VBA no Microsoft Office; grandes organizações de finanças, 
governo e manufatura mantêm macros e add-ins críticos. Forte: rapidez para prototipar 
automações, integração com Excel/Access. Pontos positivos: curva de aprendizado baixa, 
resolve tarefas de back-office. Demanda: existe para manutenção/migração e automação com 
VBA. Importância: no escritório e operações administrativas.

Cobol — Onipresente em bancos, seguradoras e governo (mainframes IBM z/OS): processamento 
de lotes, folha de pagamento, cartões, core banking. Forte: confiabilidade em alto volume 
de transações e regras de negócio legadas. Pontos positivos: estabilidade, décadas de uso 
testado. Demanda: constante (manutenção/migração, integração a APIs). Importância: crítico 
em finanças e setor público.

Assembly — Usado onde cada ciclo de CPU conta: firmware/bootloaders (BIOS/UEFI), drivers, 
partes de sistemas operacionais e embarcados; também em otimizações pontuais de bibliotecas 
(criptografia, multimídia). 
Forte: controle total de hardware e performance máxima. 
Pontos positivos: tamanho mínimo, previsibilidade. 
Demanda: nicho (sistemas de baixo nível e hardware). 
Importância: base de tudo que inicializa a máquina; não é linguagem para aplicações de 
alto nível.

C — Base de sistemas operacionais (Linux, partes de Windows/macOS), bancos de dados, 
runtime de linguagens, embarcados e redes; empresas como fabricantes de chips, sistemas 
e nuvem usam extensamente. Forte: acesso direto a memória, desempenho e portabilidade. 
Pontos positivos: ecosistema maduro, ABI estável. Demanda: alta e contínua em sistemas, 
IoT e infra. Importância: crítico em bancos para componentes de baixa latência e serviços 
de infraestrutura.

Java — Amplamente usado em back-ends corporativos, bancos, e-commerce, Android 
(legado e coexistindo com Kotlin) e Big Data (Hadoop/Spark JVM). 
Forte: performance com GC, robustez, vasto ecossistema (Spring), portabilidade. 
Pontos positivos: tooling maduro, observabilidade, segurança. 
Demanda: muito alta. 
Importância: excelente em finanças (transações, risco, integrações).

Ruby (Ruby on Rails) — Adotado por empresas de produto web (ex.: Shopify, 
GitHub/legado, Basecamp) para MVPs e plataformas SaaS. Forte: produtividade 
e convenções do Rails (“baterias inclusas”). Pontos positivos: velocidade de 
desenvolvimento, comunidade sólida. Demanda: estável porém menor que o pico; 
foco em manutenção/produtos existentes. Importância: ótimo para construir rapidamente 
aplicações de negócio; para bancos, aparece mais em front/back de portais do que em core.

JavaScript (e Node.js no servidor) — Onipresente no front-end web (React, Vue, Angular) 
e muito usado no back-end (Node.js) por empresas de streaming, fintechs e marketplaces. 
Forte: ubiquidade no navegador, ecossistema gigantesco, tempo real. 
Pontos positivos: full-stack com a mesma linguagem, NPM. 
Demanda: altíssima. 
Importância: essencial para interfaces bancárias, internet banking e painéis; 
para blogs, temas/CMS usam JS no front.

PHP — Motor de grande parte da web via WordPress, Laravel e MediaWiki (Wikipedia), 
e muitos portais/ERPs. Forte: desenvolvimento web rápido, hospedagem barata, 
CMS pronto. Pontos positivos: facilidade de deploy, vasto ecossistema de plugins. 
Demanda: constante por conta de WordPress e sistemas legados/modernos em Laravel. 
Importância: ideal para blogs e sites de conteúdo; em bancos, aparece em portais e 
intranets, não no core transacional.

Swift — Linguagem principal para iOS/iPadOS/macOS; usada por empresas com apps móveis 
de grande porte (fintechs, varejo, transporte). Forte: segurança de tipos, 
performance (LLVM), interoperabilidade com Objective-C. Pontos positivos: moderna, 
APIs Apple de primeira classe. Demanda: alta no ecossistema iOS. 
Importância: crucial para apps bancários em iPhone.

C# (.NET) — Muito usado em empresas para back-ends, integrações, desktop (Windows) 
e jogos (Unity); adotado por corporações, SaaS B2B e gov. 
Forte: produtividade com .NET, boa performance (JIT/AOT), excelente tooling (Visual Studio). 
Pontos positivos: framework completo, suporte cloud (Azure), segurança. 
Demanda: alta e estável. Importância: frequente em bancos para sistemas internos, 
APIs e integrações; para blog, há CMS em .NET, mas não é o caminho mais simples.

C++ — Usado em navegadores (Chromium), engines de jogo, trading de baixa latência, 
machine learning (núcleos), renderização e tempo real. Forte: desempenho, controle de 
memória, metaprogramação moderna (C++17/20). Pontos positivos: bibliotecas de alto 
desempenho, cross-platform. Demanda: alta em performance-critical. 
Importância: muito relevante em finanças quantitativas e sistemas de baixa latência.

2. Classificação de linguagens
Compreender a taxonomia das linguagens de programação

Linguagens de Baixo nível

Primeira geração:
Linguagem de máquina

Segunda Geração:
Linguagem Assembly

Linguagens de Alto nível

Terceira Geração:
Linguagens Imperativas

Quarta Geração:
Linguagens O.O
Linguagens Aplicativas

Quinta Geração:
Linguagens Declarativas

Paradigmas

Paradigma Imperativo Procedural
É um estilo em que o programa é descrito como uma sequência de comandos que 
modificam estado (variáveis) e são organizados em procedimentos (funções/sub-rotinas) 
chamados via pilha de chamadas, com controle de fluxo explícito (if/else, while/for, return). 
A ênfase é na decomposição top-down de problemas em rotinas reutilizáveis, passagem de 
parâmetros (por valor/referência), efeitos colaterais controlados e um modelo mental 
próximo da máquina (memória, registradores, ordem de execução), diferindo do 
declarativo/funcional (que descreve “o quê”) e do OO puro (que organiza tudo em objetos). 
Linguagens clássicas do paradigma: C, Pascal, Fortran, BASIC/Visual Basic, COBOL, Ada, 
Modula-2, Algol; e várias multi-paradigma permitem programar nesse estilo: Python, 
JavaScript, PHP, Go, Julia, Rust (com funções e mutabilidade), além de dialetos 
procedurais de SQL como PL/SQL e T-SQL; Assembly é imperativo e costuma ser estruturado 
em rotinas, embora seja de nível mais baixo que o procedural “clássico”.

Paradigma Imperativo Orientação a objetos
Organiza o programa como um conjunto de objetos que mantêm estado (dados) e expõem 
comportamentos (métodos) que o modificam; a execução ocorre por envio de mensagens/chamadas 
de métodos e controle de fluxo clássico (if/for/while) — ou seja, continua imperativo, 
mas com foco em encapsulamento, abstração, polimorfismo e herança (com preferência moderna 
por composição sobre herança). Classes definem o “molde” de objetos; interfaces/protocolos 
permitem troca de implementações; princípios SOLID, design patterns e injeção de dependência 
ajudam a manter acoplamento baixo e alta coesão. OO brilha em domínios com modelos ricos de 
negócio, UIs, apps mobile, jogos e sistemas grandes, onde modularidade e extensibilidade 
reduzem custo de evolução.
Linguagens típicas/onde OO é central: Java, C#, C++, Objective-C, Swift, Kotlin, Ruby, 
Smalltalk, Eiffel, Dart, PHP (>=5), TypeScript/JavaScript (prototipal), Python e Scala 
(multi-paradigma).

Paradigma Declarativo Funcional
Descreve o que computar, não como passo a passo: programas são compostos por funções puras 
(mesmas entradas → mesmas saídas), imutabilidade de dados, composição de funções, recursão no 
lugar de laços e forte uso de funções de ordem superior; idealmente há transparência referencial 
(uma expressão pode ser substituída por seu valor sem alterar o programa), o que facilita raciocínio, 
testes, otimizações (fusão, memoização) e paralelismo por evitar estado compartilhado; muitos 
dialetos oferecem tipos algébricos e pattern matching, e alguns adotam avaliação preguiçosa (lazy) 
para construir pipelines expressivos de transformação de dados.
Linguagens associadas: Haskell (puramente funcional, lazy), OCaml e F# (funcional com impurezas 
controladas), Clojure (funcional sobre JVM, imutabilidade persistente), Erlang/Elixir (funcional 
concorrente, atores), Scala, Scheme/Racket e Clojure/Scheme (família Lisp), além de estilos 
funcionais fortes em JavaScript/TypeScript, Python, Kotlin, Swift e Rust (todas multi-paradigma 
com suporte a imutabilidade, closures e funções de ordem superior).

Paradigma Declarativo Lógica
Modela programas como um conjunto de fatos e regras (conhecimento) e resolve problemas 
formulando consultas/objetivos: você descreve relações que devem valer e o motor lógico 
encontra soluções por inferência — tipicamente via unificação (casamento de termos), backtracking 
(busca com retrocesso) e resolução SLD; extensões com restrições (CLP) adicionam domínios como 
inteiros finitos ou reais para podar o espaço de busca. Em vez de especificar o passo-a-passo, 
você declara o que é verdade no domínio, e o sistema explora o espaço de soluções (não determinismo 
controlado), o que é poderoso para busca, planejamento, verificação, regras de negócio, IA simbólica 
e consultas recursivas (grafo/BD). Pontos fortes: expressividade, proximidade com especificações, 
prototipagem rápida e possibilidade de provas/rastreabilidade. Desafios: controle de desempenho 
(ordem das cláusulas, cortes), depuração em buscas grandes e integração com estados mutáveis/IO.
Linguagens associadas: Prolog (clássico, SWI/SICStus), Datalog (recursão em bancos/consultas), 
ASP/Answer Set Programming (ex.: clingo; semântica de modelos estáveis), ECLiPSe Prolog e CLP(FD/ℝ) 
(restrições), Mercury (tipada, modos/determinismo), Picat (lógica + restrições + planejamento), 
miniKanren (lógica relacional embutida em Scheme/Racket/Clojure), Curry (funcional-lógica). 
Ecos relacionados: motores de regras (ex.: Drools), SPARQL/OWL (lógica descritiva no Semantic Web), 
e usos inspirados em lógica em OTL/Alloy para model checking.

Estrutura de Tipos

Fracamente Tipada - PHP - Definido, mas pode modificar.
Fortemente Tipada - Java, Ruby - Predefinido e imutável.
Dinamicamente Tipada - Python, Ruby - Definido em tempo de execução.
Estaticamente Tipada - Java, C - Definido em tempo de compilação.

Grau de Abstração funciona como uma escala para linguagens: quanto mais abaixo mais próximo da
linguagem da máquina, e quanto mais alto, mais próximo da linguagem dos seres humanos.

Baixo nível - possui símbolos que representam o código de máquina propriamente - Assembly
Médio nível - possui símbolos que podem ser diretamente traduzíveis para código de máquina,
mas também possui símbolos que precisam ser processados por um compilador. - C#
Alto nível - possui símbolos complexos que necessitam de interpretação de um compilador antes
de serem transformados em linguagem de máquina. - Java, JavaScript, Phyton, Ruby

Geração

Primeira
Segunda
Terceira
Quarta
Quinta

3. Algumas comparações
Observar diferentes e similaridades entre algumas linguagens de programação.

Estrutura de controle
Declaração de váriaveis

4. Resumos e dicas
Por onde começar a programar

Front-end, Back-end, Full-Stack

As linguagens de programação são ferramentas essenciais para a comunicação com 
computadores, permitindo que os humanos traduzam suas ideias e instruções em um formato 
compreensível para as máquinas. Essa necessidade surge porque os computadores operam em 
um nível de abstração muito distante da linguagem humana, lidando com sinais elétricos e 
representações binárias de dados. Ao longo das décadas, diversas linguagens de programação 
foram criadas, cada uma com suas características, vantagens e desvantagens, impulsionadas 
pela constante evolução tecnológica e pelas demandas de diferentes áreas, como 
desenvolvimento web, ciência de dados, inteligência artificial e muitas outras.

As linguagens de programação podem ser classificadas de acordo com diversos critérios, 
como o nível de abstração, o paradigma de programação e a estrutura de tipos. O nível 
de abstração refere-se à proximidade da linguagem com a linguagem humana ou com a 
linguagem de máquina. Linguagens de alto nível, como Python e Java, são mais próximas 
da linguagem humana, com sintaxe mais intuitiva e recursos abstratos que facilitam 
o desenvolvimento de softwares complexos. Por outro lado, linguagens de baixo nível, 
como Assembly, operam mais próximas do hardware, oferecendo maior controle sobre os 
recursos da máquina, mas exigindo maior conhecimento técnico e atenção a detalhes de 
baixo nível.

Os paradigmas de programação representam diferentes abordagens para a resolução de 
problemas computacionais. O paradigma imperativo, um dos mais tradicionais, baseia-se 
na sequência de comandos e no controle direto do fluxo de execução do programa. 
Linguagens como C e COBOL são exemplos de linguagens imperativas. Já o paradigma 
orientado a objetos, presente em linguagens como Java, C++ e Python, organiza o código 
em torno de objetos, que encapsulam dados e comportamentos, promovendo a reutilização 
de código e a modularidade.

A estrutura de tipos define como os dados são representados e manipulados em uma 
linguagem de programação. Linguagens fortemente tipadas, como Java e C++, exigem que 
o tipo de cada variável seja declarado explicitamente durante a programação, garantindo 
maior segurança e previsibilidade na execução do código. Em contraste, linguagens 
fracamente tipadas, como Python e JavaScript, inferem o tipo das variáveis dinamicamente 
durante a execução, oferecendo maior flexibilidade, mas exigindo maior atenção do 
programador para evitar erros de tipo.

A escolha da linguagem de programação ideal para um projeto depende de diversos 
fatores, como a natureza do problema a ser resolvido, os recursos disponíveis, as 
preferências da equipe de desenvolvimento e as tendências do mercado. É importante 
destacar que não existe uma linguagem "melhor" do que a outra, mas sim linguagens 
mais adequadas para determinadas tarefas. Aprender os fundamentos da lógica de 
programação e ter familiaridade com diferentes paradigmas e estruturas de dados 
são habilidades valiosas para qualquer programador, independentemente da linguagem 
escolhida.

No contexto do desenvolvimento web, as linguagens de programação desempenham um papel 
fundamental na criação de sites dinâmicos e interativos. O HTML, apesar de não ser uma 
linguagem de programação propriamente dita, fornece a estrutura básica do conteúdo da 
página, enquanto o CSS define o estilo visual e o layout dos elementos. O JavaScript, 
por sua vez, adiciona interatividade e comportamento dinâmico às páginas web, respondendo 
a eventos do usuário, manipulando o DOM (Document Object Model) e comunicando-se com 
servidores web.

As linguagens de programação também são essenciais para o desenvolvimento back-end, 
que envolve a lógica do servidor, o gerenciamento de dados e a comunicação com o banco 
de dados. Linguagens como Python, Java, PHP e Ruby são amplamente utilizadas no 
desenvolvimento back-end, oferecendo frameworks e bibliotecas robustas para a construção 
de APIs, o processamento de dados e a implementação de regras de negócio.

O termo "full-stack" refere-se a profissionais que dominam tanto o desenvolvimento 
front-end quanto o back-end, sendo capazes de criar aplicações web completas, desde a 
interface do usuário até a lógica do servidor e o gerenciamento de dados. Essa 
versatilidade é altamente valorizada no mercado de trabalho, pois permite que um único 
profissional atue em todas as etapas do desenvolvimento de um projeto web.

Aprender a programar é uma jornada desafiadora e recompensadora, que exige dedicação, 
estudo e prática constante. Aprender os fundamentos da lógica de programação, experimentar 
diferentes linguagens e paradigmas, participar de comunidades online e desenvolver projetos 
pessoais são passos importantes para se tornar um programador habilidoso e versátil.